ItemPick und BoxPick

Einführung

Die ItemPick- und BoxPick-Module sind optional erhältliche Module,
welche intern auf dem

rc_visard

 laufen.

Bemerkung: Die Module sind optional und benötigen gesonderte
  ItemPick- bzw. BoxPick-

  Lizenzen

   .

Die Module liefern eine gebrauchsfertige, modellfreie
Perzeptionslösung, um robotische Pick-and-Place-Anwendungen für
Vakuum-Greifsysteme zu realisieren. Dazu analysieren die Module die
sichtbare 3D-Szene, extrahieren mittels Clustering-Verfahren ebene
Greifflächen und berechnen daraus mögliche 3D-Greifposen für die
Positionierung des Sauggreifers.

Darüber hinaus bieten beide Module:

eine intuitiv gestaltete Bedienoberfläche für Inbetriebnahme,
Konfiguration und Test auf der rc_visard Web GUI\:(Abschnitt
\ref{installation:sect-web-gui})

die Möglichkeit, sogenannte Regions of Interest (ROIs) zu definieren,
um relevante Teilbereiche der Szene auszuwählen (siehe Region of
Interest Funktionalität, Abschnitt \ref{roi:sect-roi})

eine integrierte Behältererkennung (siehe Load Carrier Funktionalität,
Abschnitt \ref{loadcarrier:sect-loadcarrier}), um in Bin-Picking-
Anwendungen ("Griff in die Kiste") Greifpunkte nur für Objekte in dem
erkannten Behälter zu berechnen

die Unterstützung von Behältern mit Fächern, sodass Greifpunkte für
Objekte nur in einem definierten Teilvolumen des Behälters berechnet
werden

die Unterstützung von sowohl statisch montierten als auch
robotergeführten Kameras. Optional kann es mit der Hand-Auge-
Kalibrierung (Abschnitt \ref{handeye_calibration:sect-handeye-
calibration}) kombiniert werden, um Greifposen in einem
benutzerdefinierten externen Koordinatensystem zu liefern.

einen Qualitätswert für jeden vorgeschlagenen Greifpunkt, der die
Ebenheit der für das Greifen verfügbaren Oberfläche bewertet

die Sortierung der berechneten Greifpunkte anhand des
Gravitationsvektors und der Größe, sodass bei gestapelten Objekten
zuerst die oberen gegriffen werden

Bemerkung: In diesem Kapitel werden die Begriffe Cluster und
  Oberfläche synonym verwendet und bezeichnen eine Menge von Punkten
  (oder Pixeln) mit ähnlichen geometrischen Eigenschaften.

Erkennung von Rechtecken (BoxPick)

Das BoxPick-Modul unterstützt die Erkennung von mehreren
Objektmodellen ("item_models") vom Typ ("type") Rechteck
("RECTANGLE"). Jedes Rechteck ist durch seine minimale und maximale
Größe definiert, wobei die minimale Größe kleiner als die maximale
Größe sein muss. Die Abmessungen sollten relativ genau angegeben
werden, um Fehldetektionen zu verhindern, jedoch eine gewisse Toleranz
beinhalten, um Messunsicherheiten und mögliche Produktionsabweichungen
zu berücksichtigen.

Optional können dem BoxPick-Modul folgende Informationen übergeben
werden:

die ID des Load Carriers, welcher die Objekte enthält

ein Teilbereich innerhalb eines Behälters, in dem Objekte detektiert
werden sollen

die ID der Region of Interest, innerhalb der nach dem Load Carrier
gesucht wird, oder -- falls kein Load Carrier angegeben ist -- die
Region of Interest, in der nach Objekten gesucht wird

die aktuelle Roboterpose, wenn die Kamera am Roboter montiert ist und
als Koordinatensystem external gewählt wurde, oder die gewählte Region
of Interest im externen Koordinatensystem definiert ist

Die zurückgegebenen Objektposen sind relativ zum Mittelpunkt des
Rechtecks definiert. Die z-Achse zeigt in Richtung der Kamera. Jedes
erkannte Rechteck beinhaltet eine "uuid" (Universally Unique
Identifier) und den Zeitstempel "timestamp" des ältesten Bildes, das
für die Erkennung benutzt wurde.

Berechnung der Greifpunkte

Die ItemPick- und BoxPick-Module bieten einen Service, um Greifpunkte
für Sauggreifer zu berechnen. Der Sauggreifer ist durch die Länge und
Breite der Greiffläche definiert.

Das ItemPick-Modul identifiziert ebene Flächen in der Szene und
unterstützt flexible und/oder deformierbare Objekte. Der Typ ("type")
dieser Objektmodelle ("item_models") ist als unbekannt ("UNKNOWN")
definiert, da sie keine gebräuchliche geometrische Form aufweisen
müssen. Optional kann eine minimale und maximale Größe angegeben
werden.

Bei BoxPick werden die Greifpunkte auf den erkannten Rechtecken
berechnet (siehe

Erkennung von Rechtecken (BoxPick)

).

Optional können den Modulen zu einer Greifpunktberechnung weitere
Informationen übergeben werden:

die ID des Load Carriers, welcher die zu greifenden Objekte enthält

ein Unterabteil (load_carrier_compartment) innerhalb eines Behälters,
in dem Greifpunkte berechnet werden sollen. Es ist durch einen Quader
definiert, dessen Pose pose relativ zum Referenzkoordinatensystem des
Behälters angegeben wird.


die ID der Region of Interest, innerhalb der nach dem Load Carrier
gesucht wird, oder -- falls kein Load Carrier angegeben ist -- die
Region of Interest, innerhalb der Greifpunkte berechnet werden

Informationen für die Kollisionsprüfung: Die ID des Greifers, um die
Kollisionsprüfung zu aktivieren, und optional ein Greif-Offset, der
die Vorgreifposition definiert. Die Kollisionsprüfung benötigt eine
gesonderte CollisionCheck-Lizenz\:(Abschnitt \ref{maintenance:sect-
updating-license}). Details zur Kollisionsprüfung sind in
CollisionCheck\:(Abschnitt \ref{itempick:sect-itempick-collision-
check-dep}) gegeben.

Ein vom ItemPick- oder BoxPick-Modul ermittelter Greifpunkt
repräsentiert die empfohlene Pose des TCP (Tool Center Point) des
Sauggreifers. Der Greifpunkt "type" ist immer auf "SUCTION" gesetzt.
Für jeden Greifpunkt liegt der Ursprung der Greifpose "pose" im
Mittelpunkt der größten von der jeweiligen Greiffläche umschlossenen
Ellipse. Die Orientierung des Greifpunkts ist ein rechtshändiges
Koordinatensystem, sodass die z-Achse orthogonal zur Greiffläche in
das zu greifende Objekt zeigt und die x-Achse entlang der längsten
Ausdehnung ausgerichtet ist.


Zusätzlich enthält jeder Greifpunkt die Abmessungen der maximal
verfügbaren Greiffläche, die als Ellipse mit den Achslängen
"max_suction_surface_length" und "max_suction_surface_width"
beschrieben wird. Der Nutzer kann Greifpunkte mit zu kleinen
Greifflächen herausfiltern, indem die minimalen Abmessungen der
Greiffläche, die vom Sauggreifer benötigt wird, angegeben werden.

Im BoxPick-Modul entspricht der Greifpunkt dem Zentrum des
detektierten Rechtecks, wobei die Achslängen der Greiffläche durch
Länge und Breite des Rechtecks gegeben sind. Falls mehr als 15% der
Rechtecksfläche ungültige Datenpunkte enthält oder durch andere
Objekte verdeckt ist, wird dem Rechteck kein Greifpunkt zugeordnet.

Jeder Greifpunkt enthält auch einen Qualitätswert ("quality"), der
einen Hinweis auf die Ebenheit der Greiffläche gibt. Dieser Wert
reicht von 0 bis 1, wobei höhere Werte für eine ebenere rekonstruierte
Oberfläche stehen.

Jeder berechnete Greifpunkt lässt sich anhand einer "uuid"
(Universally Unique Identifier) eindeutig identifizieren und enthält
zusätzlich den Zeitstempel der ältesten Bildaufnahme, auf der die
Greifpunktberechnung durchgeführt wurde.

Wechselwirkung mit anderen Modulen

Die folgenden, intern auf dem

rc_visard

 laufenden Module liefern Daten für das ItemPick- und BoxPick-Modul
oder haben Einfluss auf die Datenverarbeitung.

Bemerkung: Jede Konfigurationsänderung dieser Module kann direkte
  Auswirkungen auf die Qualität oder das Leistungsverhalten der
  ItemPick- und Boxpick-Module haben.

Stereokamera und Stereo-Matching

Folgende Daten werden vom ItemPick- und BoxPick-Modul verarbeitet:

die rektifizierten Bilder des Stereokamera-Moduls (rc_stereocamera,
Abschnitt \ref{stereo_camera:sect-stereo-camera})

die Disparitäts-, Konfidenz- und Fehlerbilder des Stereo-Matching-
Moduls (rc_stereomatching, Abschnitt \ref{stereo_matching:sect-stereo-
matching})

Für alle genutzten Bilder ist garantiert, dass diese nach dem Auslösen
des Services aufgenommen wurden.

Schätzung der Gravitationsrichtung

Jedes Mal, wenn eine Behältererkennung oder Greifpunktberechnung
durchgeführt wird, schätzt das ItemPick- bzw. BoxPick-Modul die
Gravitationsrichtung basierend auf den IMU-Daten des

rc_visard

.

Bemerkung: Die Richtung des Gravitationsvektors wird durch Messungen
  der linearen Beschleunigung der IMU bestimmt. Für eine korrekte
  Schätzung des Gravitationsvektors muss der

  rc_visard

   stillstehen.

IOControl und Projektor-Kontrolle

Für den Anwendungsfall, dass der

rc_visard

 zusammen mit einem externen Musterprojektor und dem Modul für

IOControl und Projektor-Kontrolle

 ("rc_iocontrol") betrieben wird, wird empfohlen, den Projektor an
GPIO Out 1 anzuschließen und den Aufnahmemodus des Stereokamera-Moduls
auf "SingleFrameOut1" zu setzen (siehe

Stereomatching-Parameter

), damit bei jedem Aufnahme-Trigger ein Bild mit und ohne
Projektormuster aufgenommen wird.

Alternativ kann der verwendete digitale Ausgang in den Betriebsmodus
"ExposureAlternateActive" geschaltet werden (siehe

Beschreibung der Laufzeitparameter

).

In beiden Fällen sollte die Belichtungszeitregelung ("exp_auto_mode")
auf "AdaptiveOut1" gesetzt werden, um die Belichtung beider Bilder zu
optimieren (siehe

Stereokamera-Parameter

).

Hand-Auge-Kalibrierung

Falls die Kamera zu einem Roboter kalibriert wurde, können die
ItemPick- und BoxPick-Module automatisch Posen im
Roboterkoordinatensystem ausgeben. Für die

Services

 kann das Koordinatensystem der berechneten Posen mit dem Argument
"pose_frame" spezifiziert werden.

Zwei verschiedene Werte für "pose_frame" können gewählt werden:

Kamera-Koordinatensystem (camera): Alle Posen sind im Kamera-
Koordinatensystem angegeben und es ist kein zusätzliches Wissen über
die Lage der Kamera in seiner Umgebung notwendig. Das bedeutet
insbesondere, dass sich ROIs oder Load Carrier, welche in diesem
Koordinatensystem angegeben sind, mit der Kamera bewegen. Es liegt
daher in der Verantwortung des Anwenders, in solchen Fällen die
entsprechenden Posen der Situation entsprechend zu aktualisieren
(beispielsweise für den Anwendungsfall einer robotergeführten Kamera).

Benutzerdefiniertes externes Koordinatensystem (external): Alle Posen
sind im sogenannten externen Koordinatensystem angegeben, welches vom
Nutzer während der Hand-Auge-Kalibrierung gewählt wurde. In diesem
Fall bezieht das ItemPick- oder BoxPick-Modul alle notwendigen
Informationen über die Kameramontage und die kalibrierte Hand-Auge-
Transformation automatisch vom Modul Hand-Auge-
Kalibrierung\:(Abschnitt \ref{handeye_calibration:sect-handeye-
calibration}). Für den Fall einer robotergeführten Kamera ist vom
Nutzer zusätzlich die jeweils aktuelle Roboterpose robot_pose
anzugeben.

Bemerkung: Wenn keine Hand-Auge-Kalibrierung durchgeführt wurde bzw.
  zur Verfügung steht, muss als Referenzkoordinatensystem "pose_frame"
  immer "camera" angegeben werden.

Zulässige Werte zur Angabe des Referenzkoordinatensystems sind
"camera" und "external". Andere Werte werden als ungültig
zurückgewiesen.

CollisionCheck

Falls eine CollisionCheck-Lizenz verfügbar ist, kann die
Kollisionsprüfung für die Greifpunktberechnung der ItemPick und
BoxPick Module aktiviert werden, indem die ID des benutzten Greifers
und optional ein Greif-Offset an den "compute_grasps" Service
übergeben werden. Der Greifer muss im CollisionCheck-Modul definiert
werden (siehe

Erstellen eines Greifers

) und Details über die Kollisionsprüfung werden in

Integrierte Kollisionsprüfung in anderen Modulen

 gegeben.

Wenn die Kollisionsprüfung aktiviert ist, werden nur kollisionsfreie
Greifpunkte zurückgeliefert. Jedoch werden in den Visualisierungen auf
der

BoxPick

- und

ItemPick

-Seite der Web GUI kollidierende Greifpunkte als schwarze Ellipsen
dargestellt.

Die Laufzeitparameter des CollisionCheck-Moduls beeinflussen die
Kollisionserkennung wie in

CollisionCheck-Parameter

 beschrieben.

Parameter

Die ItemPick- und BoxPick-Module werden in der REST-API als
"rc_itempick" und "rc_boxpick" bezeichnet und in der

Web GUI

 auf den Seiten

BoxPick

 bzw.

ItemPick

 (unter der Seite

Module

) dargestellt. Der Benutzer kann die Parameter entweder dort oder über
die

REST-API-Schnittstelle

 ändern.

Übersicht über die Parameter

Diese Softwaremodule bieten folgende Laufzeitparameter:

Applikationsspezifische Laufzeitparameter der rc_itempick und
rc_boxpick Module              Name  Typ  Min.  Max.  Default
Beschreibung  max_grasps  int32  1  20  5  Maximale Anzahl von
bereitgestellten Greifpunkten

Laufzeitparameter der rc_itempick und rc_boxpick Module für die
Behältererkennung              Name  Typ  Min.  Max.  Default
Beschreibung  load_carrier_crop_distance  float64  0.0  0.05  0.005
Sicherheitsspielraum um den das Load Carrier Innenmaß verringert wird,
um eine Region of Interest für die Erkennung zu definieren
load_carrier_model_tolerance  float64  0.003  0.025  0.008  Gibt an,
wie weit die Abmessungen des Load Carriers von den Werten im Modell
abweichen dürfen.

Laufzeitparameter der rc_itempick und rc_boxpick Module für das
Clustering-Verfahren              Name  Typ  Min.  Max.  Default
Beschreibung  cluster_max_dimension  float64  0.05  0.8  0.3  Nur für
rc_itempick. Größenbeschränkung für mögliche Greifflächen in Metern.
cluster_max_curvature  float64  0.005  0.5  0.11  Maximal erlaubte
Krümmung für Greifflächen  clustering_patch_size  int32  3  10  4  Nur
für rc_itempick. Pixelgröße der Patches für die Unterteilung des
Tiefenbildes im ersten Clustering-Schritt  clustering_max_surface_rmse
float64  0.0005  0.01  0.004  Maximal erlaubte Abweichung (Root Mean
Square Error, RMSE) von Punkten zur Greiffläche in Metern
clustering_discontinuity_factor  float64  0.5  5.0  1.0  Erlaubte
Unebenheit von Greifflächen

Beschreibung der Laufzeitparameter

Die Laufzeitparameter werden zeilenweise auf den

ItemPick

- bzw.

BoxPick

-Seiten in der Web GUI dargestellt. Im folgenden wird der Name des
Parameters in der Web GUI in Klammern hinter dem eigentlichen
Parameternamen angegeben. Die Parameter sind in derselben Reihenfolge
wie in der Web GUI aufgelistet:

"max_grasps" (
Anzahl Greifpunkte

)
   ist die maximale Anzahl von bereitgestellten Greifpunkten.

"load_carrier_model_tolerance" (
Modelltoleranz

)
   siehe

   Parameter der Load Carrier Funktionalität

   .

"load_carrier_crop_distance" (
Cropping

)
   siehe

   Parameter der Load Carrier Funktionalität

   .

"cluster_max_dimension" (
Nur für ItemPick

,
Maximale Größe

)
   setzt eine Größenbeschränkung für mögliche Greifflächen in Metern.
   Flächen, die nicht durch einen Kreis dieses Durchmessers
   umschrieben werden können, werden aussortiert.

"cluster_max_curvature" (
Maximale Krümmung

)
   ist die maximal erlaubte Krümmung für Greifflächen. Je kleiner
   dieser Wert ist, desto mehr mögliche Greifflächen werden in
   kleinere Flächen mit weniger Krümmung aufgeteilt.

"clustering_patch_size" (
Nur für ItemPick

,
Patchgröße

)
   ist die Pixelgröße der Patches für die Unterteilung des
   Tiefenbildes im ersten Clustering-Schritt.

"clustering_discontinuity_factor" (
Unstetigkeitsfaktor

)
   beschreibt die erlaubte Unebenheit von Greifflächen. Je kleiner
   dieser Wert ist, umso mehr werden mögliche Greifflächen in kleinere
   Flächen mit weniger Unebenheiten aufgeteilt.

"clustering_max_surface_rmse" (
Maximaler RMSE

)
   ist die maximal erlaubte Abweichung (Root Mean Square Error, RMSE)
   von Punkten zur Greiffläche in Metern.

Statuswerte

Statuswerte der "rc_itempick" und "rc_boxpick" Module:

Statuswerte der rc_itempick und rc_boxpick Module      Name
Beschreibung  data_acquisition_time  Zeit in Sekunden, für die beim
letzten Aufruf auf Bilddaten gewartet werden musste. Normalerweise
sollte dieser Wert zwischen 0.5 und 0.6 Sekunden bei Tiefenbildern der
Auflösung High liegen.  grasp_computation_time  Laufzeit für die
Greifpunktberechnung beim letzten Aufruf in Sekunden
last_timestamp_processed  Zeitstempel des letzten verarbeiteten
Bilddatensatzes  load_carrier_detection_time  Laufzeit für die letzte
Behältererkennung in Sekunden  state  Aktueller Zustand des ItemPick-
bzw. BoxPick-Moduls

Folgende "state"-Werte werden gemeldet.

Mögliche Werte für den Zustand der ItemPick und BoxPick Module
Zustand  Beschreibung  IDLE  Das Modul ist inaktiv.  RUNNING  Das
Modul wurde gestartet und ist bereit, Behälter zu erkennen und
Greifpunkte zu berechnen.  FATAL  Ein schwerwiegender Fehler ist
aufgetreten.

Services

Die angebotenen Services von "rc_itempick" bzw. "rc_boxpick" können
mithilfe der

REST-API-Schnittstelle

 oder der

rc_visard


Web GUI

 ausprobiert und getestet werden.

Zusätzlich zur eigentlichen Serviceantwort gibt jeder Service einen
sogenannten "return_code" bestehend aus einem Integer-Wert und einer
optionalen Textnachricht zurück. Erfolgreiche Service-Anfragen werden
mit einem Wert von "0" quittiert. Positive Werte bedeuten, dass die
Service-Anfrage zwar erfolgreich bearbeitet wurde, aber zusätzliche
Informationen zur Verfügung stehen. Negative Werte bedeuten, dass
Fehler aufgetreten sind. Für den Fall, dass mehrere Rückgabewerte
zutreffend wären, wird der kleinste zurückgegeben, und die
entsprechenden Textnachrichten werden in "return_code.message"
akkumuliert.

Die folgende Tabelle führt die möglichen Rückgabe-Codes an:

Rückgabecodes der Services des ItemPick- bzw. BoxPick-Moduls      Code
Beschreibung  0  Erfolgreich  -1  Ungültige(s) Argument(e)  -4  Die
maximal erlaubte Zeitspanne von 5.0 Sekunden für die interne Akquise
der Bilddaten wurde überschritten.  -10  Das neue Element konnte nicht
hinzugefügt werden, da die maximal speicherbare Anzahl an Load
Carriern oder ROIs überschritten wurde.  -200  Ein schwerwiegender
interner Fehler ist aufgetreten.  -301  Für die Anfrage zur
Greifpunktberechnung compute_grasps wurden mehrere Objektmodelle
(item_models) vom Typ UNKNOWN übergeben.  -302  Mehr als ein Behälter
wurde für die Anfrage detect_load_carriers oder detect_filling_level
angegeben. Momentan wird nur ein Behälter gleichzeitig unterstützt.
10  Die maximal speicherbare Anzahl an Load Carriern oder ROIs wurde
erreicht.  11  Mit dem Aufruf von set_load_carrier oder
set_region_of_interest wurde ein bereits existierendes Objekt mit
derselben id überschrieben.  100  Die angefragten Load Carrier wurden
in der Szene nicht gefunden.  101  Es wurden keine gültigen
Greifflächen in der Szene gefunden.  102  Der detektierte Load Carrier
ist leer.  103  Alle berechneten Greifpunkte sind in Kollision mit dem
Load Carrier.  200  Das Modul ist im Zustand IDLE.  300  Ein gültiges
robot_pose-Argument wurde angegeben, ist aber nicht erforderlich.  400
Der Serviceanfrage compute_grasps wurden keine Objektmodelle
(item_models) als Argumente mitgegeben.

Das ItemPick- bzw. BoxPick-Modul stellt folgende Services zur
Verfügung.

start

   versetzt das ItemPick-Modul in den Zustand "RUNNING". Es kann
   vorkommen, dass der Zustandsübergang noch nicht vollständig
   abgeschlossen ist, wenn die Serviceantwort generiert wird. In
   diesem Fall liefert diese den entsprechenden, sich von "RUNNING"
   unterscheidenden Zustand zurück.

   Dieser Service hat keine Argumente.

   Die Definition der *Response* mit jeweiligen Datentypen ist:

      {
        "accepted": "bool",
        "current_state": "string"
      }

stop

   stoppt das Modul und versetzt es in den Zustand "IDLE". Es kann
   vorkommen, dass der Zustandsübergang noch nicht vollständig
   abgeschlossen ist, wenn die Serviceantwort generiert wird. In
   diesem Fall liefert diese den entsprechenden, sich von "IDLE"
   unterscheidenden Zustand zurück.

   Dieser Service hat keine Argumente.

   Die Definition der *Response* mit jeweiligen Datentypen ist:

      {
        "accepted": "bool",
        "current_state": "string"
      }

set_region_of_interest

   siehe

   set_region_of_interest

   .

get_regions_of_interest

   siehe

   get_regions_of_interest

   .

delete_regions_of_interest

   siehe

   delete_regions_of_interest

   .

set_load_carrier

   siehe

   set_load_carrier

   .

get_load_carriers

   siehe

   get_load_carriers

   .

delete_load_carriers

   siehe

   delete_load_carriers

   .

detect_load_carriers

   siehe

   detect_load_carriers

   .

detect_filling_level

   siehe

   detect_filling_level

   .

detect_items (nur BoxPick)

   löst die Erkennung von Rechtecken aus,  wie in

   Erkennung von Rechtecken (BoxPick)

    beschrieben.

   Request:

      Die Definition der *Request*-Argumente mit jeweiligen Datentypen
      ist:

         {
           "item_models": [
             {
               "rectangle": {
                 "max_dimensions": {
                   "x": "float64",
                   "y": "float64"
                 },
                 "min_dimensions": {
                   "x": "float64",
                   "y": "float64"
                 }
               },
               "type": "string"
             }
           ],
           "load_carrier_compartment": {
             "box": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             },
             "pose": {
               "orientation": {
                 "w": "float64",
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "position": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               }
             }
           },
           "load_carrier_id": "string",
           "pose_frame": "string",
           "region_of_interest_id": "string",
           "robot_pose": {
             "orientation": {
               "w": "float64",
               "x": "float64",
               "y": "float64",
               "z": "float64"
             },
             "position": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             }
           }
         }

      Obligatorische Serviceargumente:

         "pose_frame": siehe

         Hand-Auge-Kalibrierung

         .

         "item_models": Liste von Rechtecken mit minimaler und
         maximaler Größe, wobei die minimale Größe kleiner als die
         maximale Größe sein muss. Die Abmessungen sollten relativ
         genau angegeben werden, um Fehldetektionen zu verhindern,
         jedoch eine gewisse Toleranz beinhalten, um
         Messunsicherheiten und mögliche Produktionsabweichungen zu
         berücksichtigen.

      Möglicherweise benötigte Serviceargumente:

         "robot_pose": siehe

         Hand-Auge-Kalibrierung

         .

      Optionale Serviceargumente:

         "load_carrier_id": ID des Load Carriers, welcher die zu
         erkennenden Objekte enthält.

         "load_carrier_compartment": Teilvolumen (Fach oder Abteil) in
         einem zu detektierenden Load Carrier (Behälter), in dem
         Objekte erkannt werden sollen.

         "region_of_interest_id": Falls "load_carrier_id" gesetzt ist,
         die ID der Region of Interest, innerhalb welcher nach dem
         Load Carrier gesucht wird. Andernfalls die ID der Region of
         Interest, in der nach Objekten gesucht wird.

   Response:

      Die Definition der *Response* mit jeweiligen Datentypen ist:

         {
           "items": [
             {
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "rectangle": {
                 "x": "float64",
                 "y": "float64"
               },
               "timestamp": {
                 "nsec": "int32",
                 "sec": "int32"
               },
               "type": "string",
               "uuid": "string"
             }
           ],
           "load_carriers": [
             {
               "id": "string",
               "inner_dimensions": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "outer_dimensions": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "overfilled": "bool",
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "rim_thickness": {
                 "x": "float64",
                 "y": "float64"
               }
             }
           ],
           "return_code": {
             "message": "string",
             "value": "int16"
           },
           "timestamp": {
             "nsec": "int32",
             "sec": "int32"
           }
         }

      "load_carriers": Liste der erkannten Load Carrier (Behälter).

      "items": Liste an erkannten Rechtecken.

      "timestamp": Zeitstempel des Bildes, auf dem die Erkennung
      durchgeführt wurde.

      "return_code": enthält mögliche Warnungen oder Fehlercodes und
      Nachrichten.

compute_grasps (für ItemPick)

   löst die Erkennung von Greifpunkten für einen Sauggreifer aus,  wie
   in

   Berechnung der Greifpunkte

    beschrieben.

   Request:

      Die Definition der *Request*-Argumente mit jeweiligen Datentypen
      ist:

         {
           "collision_detection": {
             "gripper_id": "string",
             "pre_grasp_offset": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             }
           },
           "item_models": [
             {
               "type": "string",
               "unknown": {
                 "max_dimensions": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "min_dimensions": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               }
             }
           ],
           "load_carrier_compartment": {
             "box": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             },
             "pose": {
               "orientation": {
                 "w": "float64",
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "position": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               }
             }
           },
           "load_carrier_id": "string",
           "pose_frame": "string",
           "region_of_interest_id": "string",
           "robot_pose": {
             "orientation": {
               "w": "float64",
               "x": "float64",
               "y": "float64",
               "z": "float64"
             },
             "position": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             }
           },
           "suction_surface_length": "float64",
           "suction_surface_width": "float64"
         }

      Obligatorische Serviceargumente:

         "pose_frame": siehe

         Hand-Auge-Kalibrierung

         .

         "suction_surface_length": Länge der Greiffläche des
         verwendeten Vakuum-Greifsystems.

         "suction_surface_width": Breite der Greiffläche des
         verwendeten Vakuum-Greifsystems.

      Möglicherweise benötigte Serviceargumente:

         "robot_pose": siehe

         Hand-Auge-Kalibrierung

         .

      Optionale Serviceargumente:

         "load_carrier_id": ID des Load Carriers, welcher die zu
         greifenden Objekte enthält.

         "load_carrier_compartment": Teilvolumen (Fach oder Abteil) in
         einem zu detektierenden Load Carrier (Behälter), in dem
         Greifpunkte berechnet werden sollen.

         "region_of_interest_id": Falls "load_carrier_id" gesetzt ist,
         die ID der Region of Interest, innerhalb welcher nach dem
         Load Carrier gesucht wird. Andernfalls die ID der Region of
         Interest, innerhalb der Greifpunkte berechnet werden.

         "item_models": Liste von unbekannten Objekten mit minimaler
         und maximaler Größe, wobei die minimale Größe kleiner als die
         maximale Größe sein muss. Nur ein Objekt "item_model" vom Typ
         "UNKNOWN" wird aktuell unterstützt.

         "collision_detection": siehe

         Integrierte Kollisionsprüfung in anderen Modulen

         . Die Kollisionsprüfung benötigt eine gesonderte
         CollisionCheck-

         Lizenz

         .

   Response:

      Die Definition der *Response* mit jeweiligen Datentypen ist:

         {
           "grasps": [
             {
               "item_uuid": "string",
               "max_suction_surface_length": "float64",
               "max_suction_surface_width": "float64",
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "quality": "float64",
               "timestamp": {
                 "nsec": "int32",
                 "sec": "int32"
               },
               "type": "string",
               "uuid": "string"
             }
           ],
           "load_carriers": [
             {
               "id": "string",
               "inner_dimensions": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "outer_dimensions": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "overfilled": "bool",
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "rim_thickness": {
                 "x": "float64",
                 "y": "float64"
               }
             }
           ],
           "return_code": {
             "message": "string",
             "value": "int16"
           },
           "timestamp": {
             "nsec": "int32",
             "sec": "int32"
           }
         }

      "load_carriers": Liste der erkannten Load Carrier (Behälter).

      "grasps": sortierte Liste an Sauggreifpunkten.

      "timestamp": Zeitstempel des Bildes, auf dem die Erkennung
      durchgeführt wurde.

      "return_code": enthält mögliche Warnungen oder Fehlercodes und
      Nachrichten.

compute_grasps (für BoxPick)

   löst die Erkennung von Rechtecken und Berechnung von Greifposen für
   diese Rechtecke aus, wie in

   Berechnung der Greifpunkte

    beschrieben.

   Request:

      Die Definition der *Request*-Argumente mit jeweiligen Datentypen
      ist:

         {
           "collision_detection": {
             "gripper_id": "string",
             "pre_grasp_offset": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             }
           },
           "item_models": [
             {
               "rectangle": {
                 "max_dimensions": {
                   "x": "float64",
                   "y": "float64"
                 },
                 "min_dimensions": {
                   "x": "float64",
                   "y": "float64"
                 }
               },
               "type": "string"
             }
           ],
           "load_carrier_compartment": {
             "box": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             },
             "pose": {
               "orientation": {
                 "w": "float64",
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "position": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               }
             }
           },
           "load_carrier_id": "string",
           "pose_frame": "string",
           "region_of_interest_id": "string",
           "robot_pose": {
             "orientation": {
               "w": "float64",
               "x": "float64",
               "y": "float64",
               "z": "float64"
             },
             "position": {
               "x": "float64",
               "y": "float64",
               "z": "float64"
             }
           },
           "suction_surface_length": "float64",
           "suction_surface_width": "float64"
         }

      Obligatorische Serviceargumente:

         "pose_frame": siehe

         Hand-Auge-Kalibrierung

         .

         "item_models": Liste von Rechtecken mit minimaler und
         maximaler Größe, wobei die minimale Größe kleiner als die
         maximale Größe sein muss. Die Abmessungen sollten relativ
         genau angegeben werden, um Fehldetektionen zu verhindern,
         jedoch eine gewisse Toleranz beinhalten, um
         Messunsicherheiten und mögliche Produktionsabweichungen zu
         berücksichtigen.

         "suction_surface_length": Länge der Greiffläche des
         verwendeten Vakuum-Greifsystems.

         "suction_surface_width": Breite der Greiffläche des
         verwendeten Vakuum-Greifsystems.

      Möglicherweise benötigte Serviceargumente:

         "robot_pose": siehe

         Hand-Auge-Kalibrierung

         .

      Optionale Serviceargumente:

         "load_carrier_id": ID des Load Carriers, welcher die zu
         greifenden Objekte enthält.

         "load_carrier_compartment": Teilvolumen (Fach oder Abteil) in
         einem zu detektierenden Load Carrier (Behälter), in dem
         Greifpunkte berechnet werden sollen.

         "region_of_interest_id": Falls "load_carrier_id" gesetzt ist,
         die ID der Region of Interest, innerhalb welcher nach dem
         Load Carrier gesucht wird. Andernfalls die ID der Region of
         Interest, innerhalb der Greifpunkte berechnet werden.

         "collision_detection": siehe

         Integrierte Kollisionsprüfung in anderen Modulen

         . Die Kollisionsprüfung benötigt eine gesonderte
         CollisionCheck-

         Lizenz

         .

   Response:

      Die Definition der *Response* mit jeweiligen Datentypen ist:

         {
           "grasps": [
             {
               "item_uuid": "string",
               "max_suction_surface_length": "float64",
               "max_suction_surface_width": "float64",
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "quality": "float64",
               "timestamp": {
                 "nsec": "int32",
                 "sec": "int32"
               },
               "type": "string",
               "uuid": "string"
             }
           ],
           "items": [
             {
               "grasp_uuids": [
                 "string"
               ],
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "rectangle": {
                 "x": "float64",
                 "y": "float64"
               },
               "timestamp": {
                 "nsec": "int32",
                 "sec": "int32"
               },
               "type": "string",
               "uuid": "string"
             }
           ],
           "load_carriers": [
             {
               "id": "string",
               "inner_dimensions": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "outer_dimensions": {
                 "x": "float64",
                 "y": "float64",
                 "z": "float64"
               },
               "overfilled": "bool",
               "pose": {
                 "orientation": {
                   "w": "float64",
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 },
                 "position": {
                   "x": "float64",
                   "y": "float64",
                   "z": "float64"
                 }
               },
               "pose_frame": "string",
               "rim_thickness": {
                 "x": "float64",
                 "y": "float64"
               }
             }
           ],
           "return_code": {
             "message": "string",
             "value": "int16"
           },
           "timestamp": {
             "nsec": "int32",
             "sec": "int32"
           }
         }

      "load_carriers": Liste der erkannten Load Carrier (Behälter).

      "items": sortierte Liste von Sauggreifpunkten auf den erkannten
      Rechtecken.

      "grasps": sortierte Liste an Sauggreifpunkten.

      "timestamp": Zeitstempel des Bildes, auf dem die Erkennung
      durchgeführt wurde.

      "return_code": enthält mögliche Warnungen oder Fehlercodes und
      Nachrichten.

save_parameters

   Beim Aufruf dieses Services werden die aktuellen
   Parametereinstellungen des ItemPick- oder BoxPick-Moduls auf dem

   rc_visard

    gespeichert. Das bedeutet, dass diese Werte selbst nach einem
   Neustart angewandt werden. Bei Firmware-Updates oder
   -Wiederherstellungen werden sie jedoch wieder auf den Standardwert
   gesetzt.

   Dieser Service hat keine Argumente.

   Die Definition der *Response* mit jeweiligen Datentypen ist:

      {
        "return_code": {
          "message": "string",
          "value": "int16"
        }
      }

reset_defaults

   Hiermit werden die Werkseinstellungen der Parameter dieses Moduls
   wiederhergestellt und angewandt ("factory reset"). Dies betrifft
   nicht die konfigurierten ROIs und Load Carrier.

   Dieser Service hat keine Argumente.

   Die Definition der *Response* mit jeweiligen Datentypen ist:

      {
        "return_code": {
          "message": "string",
          "value": "int16"
        }
      }
